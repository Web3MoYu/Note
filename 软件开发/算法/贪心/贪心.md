# 贪心

### 1.1 贪心算法的定义

> **贪心算法（Greedy Algorithm）**：一种在每次决策时，总是采取在当前状态下的最好选择，从而希望导致结果是最好或最优的算法。

贪心算法是一种改进的「分步解决算法」，其核心思想是：将求解过程分成「若干个步骤」，然后根据题意选择一种「度量标准」，每个步骤都应用「贪心原则」，选取当前状态下「最好 / 最优选择（局部最优解）」，并以此希望最后得出的结果也是「最好 / 最优结果（全局最优解）」。

换句话说，贪心算法不从整体最优上加以考虑，而是一步一步进行，每一步只以当前情况为基础，根据某个优化测度做出局部最优选择，从而省去了为找到最优解要穷举所有可能所必须耗费的大量时间。

### 1.2 贪心算法的特征

对许多问题来说，可以使用贪心算法，通过局部最优解而得到整体最优解或者是整体最优解的近似解。但并不是所有问题，都可以使用贪心算法的。

一般来说，这些能够使用贪心算法解决的问题必须满足下面的两个特征：

1. **贪心选择性质**
2. **最优子结构**

#### 1.2.1 贪心选择性质

> **贪心选择性质**：指的是一个问题的全局最优解可以通过一系列局部最优解（贪心选择）来得到。

换句话说，当进行选择时，我们直接做出在当前问题中看来最优的选择，而不用去考虑子问题的解。在做出选择之后，才会去求解剩下的子问题，如下图所示。

![贪心选择性质](https://qcdn.itcharge.cn/images/20240513163300.png)

贪心算法在进行选择时，可能会依赖之前做出的选择，但不会依赖任何将来的选择或是子问题的解。运用贪心算法解决的问题在程序的运行过程中无回溯过程。

#### 1.2.2 最优子结构性质

> **最优子结构性质**：指的是一个问题的最优解包含其子问题的最优解。

问题的最优子结构性质是该问题能否用贪心算法求解的关键。

举个例子，如下图所示，原问题$S=\{a_1,a_2,a_3,a_4\}$，在 $a_1$ 步我们通过贪心选择选出一个当前最优解之后，问题就转换为求解$S_{子问题}=\{a_1,a_2,a_3,a_4\}$。如果原问题 $S$ 的最优解可以由「第$a_1$步通过贪心选择的局部最优解」和「 $S_{子问题}$的最优解」构成，则说明该问题满足最优子结构性质。

也就是说，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质。

![最优子结构性质](https://qcdn.itcharge.cn/images/20240513163310.png)

在做了贪心选择后，满足最优子结构性质的原问题可以分解成规模更小的类似子问题来解决，并且可以通过贪心选择和子问题的最优解推导出问题的最优解。

反之，如果不能利用子问题的最优解推导出整个问题的最优解，那么这种问题就不具有最优子结构。



## 题目

> 1.根据某种标准建立一个比较器来排序
>
> 2.根据某种标准建立一个比较器来组成堆

**最低字典序**

> 给你一串字符串Strs，你需要将其按照任意顺序拼接成一个新的字符串，需要保证拼接出的字符串是最低字典序的
>
> **字典序**：对于”abc"和"bc"来说 bc的字典序大于abc

```java
public static String lowestString(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    // 贪心策略：按照s1+s2和s2+s1的字典序进行排序，然后将字符串依次拼接即可
    Arrays.sort(strs, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));
    StringBuilder res = new StringBuilder();
    for (String cur : strs){
        res.append(cur);
    }
    return res.toString();
}
```

**最大钱数**

> **输入：**
>
> 正数数组costs，正数数组profits，正数k，正数m
>
> **含义：**
>
>  costs[i]表示i号项目的花费 
>
> profits[i]表示i号项目在扣除花费之后还能挣到的钱（利润） 
>
> k表示你只能串行的最多做k个项目 
>
> m表示你初始的资金说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。
>
> 输出：你最后获得的最大钱数。

> **策略**：先将所有数据放到一个按照花费排序的小根堆，然后使用当前初始资金，去小根堆里拿数据全部放到一个按照利润排序的大根堆里。然后从大根堆里弹出一个最好的，在去小根堆里解锁新的资金。

```java
public static Node{
    public int c;
    public int p;
}
    
public static int maxProfits(int k, int m, int[] profits, int[] costs){
    PriorityQueue<Node> minCostQ = new PriorityQueue<>(o1.c-o2.c);
    PriorityQueue<Node> maxProfitQ = new PriorityQueue<>(o2.p-o1.p);
    
    // 所有项目放到小根堆
    for (int i = 0; i < profits.length; i++){
        minCostQ.add(new Node(profits[i], costs[i]));
    }
    
    for (int i = 0; i < k; i++){
        // 解锁能力所及的项目
        while(!minCostQ.isEmpty() && minCostQ.peek() <= m){
            maxProfitQ.add(minCostQ.pop());
        }
        
        if (maxProfitQ.isEmpty()){
            return w;
        }
        w += maxProfitQ.pop().p;
    }
    return w;
}
```

