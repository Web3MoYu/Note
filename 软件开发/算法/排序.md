# 选择排序

**选择排序（Selection Sort）基本思想**：

​	将数组分为两个区间：左侧为已排序区间，右侧为未排序区间。每趟从未排序区间中选择一个值最小的元素，放到已排序区间的末尾，从而将该元素划分到已排序区间。

## 实现步骤

假设数组的元素个数为 ***n*** 个，则选择排序的算法步骤如下：

1.初始状态下无已排序区间，未排序区间为**[0,n-1]**

2.遍历未排序区间**[0,n-1]**，使用变量**minIndex**记录区间中最小的元素位置，将**minIndex**标记处的元素和下标为0的元素交换，此时未排序区间为**[1,n-1]**。

3.重复以上步骤即可

## 代码实现

```java
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        AlgUtils.swap(arr, i, minIndex);
    }
}
```

# 冒泡排序



> **冒泡排序（Bubble Sort）基本思想**：
>
> 经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。

这个过程就像水底的气泡一样从底部向上「冒泡」到水面，这也是冒泡排序法名字的由来。

接下来，我们使用「冒泡」的方式来模拟一下这个过程。

1. 首先将数组想象是一排「泡泡」，元素值的大小与泡泡的大小成正比。
2. 然后从左到右依次比较相邻的两个「泡泡」：
   1. 如果左侧泡泡大于右侧泡泡，则交换两个泡泡的位置。
   2. 如果左侧泡泡小于等于右侧泡泡，则两个泡泡保持不变。
3. 这 11 趟遍历完成之后，最大的泡泡就会放置到所有泡泡的最右侧，就像是「泡泡」从水底向上浮到了水面。

## 代码实现

```java
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = arr.length - 1; i > 0; i--) {
        for (int j = 0; j < i; j++) {
            if (arr[j] > arr[j + 1]) {
                AlgUtils.swap(arr, j, j + 1);
            }
        }
    }
}
```

# 插入排序



> **插入排序（Insertion Sort）基本思想**：
>
> 将数组分为两个区间：左侧为有序区间，右侧为无序区间。每趟从无序区间取出一个元素，然后将其插入到有序区间的适当位置。

插入排序在每次插入一个元素时，该元素会在有序区间找到合适的位置，因此每次插入后，有序区间都会保持有序。

## 实现步骤

1. 初始状态下，有序区间为**[0,0]**，无序区间为**[1,n-1]**
2. 取出无序区间中的第一个元素即**arr[1]**，**从右往左**遍历有序区间中的元素，直到找到比**arr[1]**大的元素，说明找到了插入位置，将二者交换
3. 然后，有序区间为**[0,1]**,无序区间为**[2,n-1]**，然后重复次步骤

![插入排序实现步骤](http://qcdn.itcharge.cn/images/20230816175619.png)

## 代码实现

```java
private static void insertSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = 0; i < arr.length; i++) {
        for (int j = i; j > 0 && arr[j] < arr[j - 1]; j--) {
            AlgUtils.swap(arr, j, j - 1);
        }
    }
}
```

# 归并排序



**归并排序（Merge Sort）基本思想**：

采用经典的分治策略，先递归地将当前数组平均分成两半，然后将有序数组两两合并，最终合并成一个有序数组。

## 算法步骤

假设数组的元素个数为 n 个，则归并排序的算法步骤如下：

1.**分解过程**

- 找到数组中心位**mid**,从中心位置将数组分成左右两个数组left、right
- 对左右数组进行递归分解
- 最终将数组分解为n个长度均为1的有序子数组

2.**归并过程**

- 使用一个**辅助数组res**，长度为**R-L+1**
- 使用两个**指针p1和p2**，分别代表合并的两个数组**left和right**
- 比较两个数组指向的元素、将两个有序子数组中较小的元素放入**res**中，同时res的**下标自增**
- **重复3步骤**，知道有一方越界为止
- 将另一个数组中剩余元素放到res中
- 返回res即可

![归并排序算法步骤](http://qcdn.itcharge.cn/images/20230817103814.png)

## 代码实现

```java
public static void mergeSort(int[] arr, int L, int R) {
    if (L == R) {
        return;
    }
    int mid = L + ((R - L) >> 1);
    mergeSort(arr, L, mid);
    mergeSort(arr, mid + 1, R);
    merge(arr, L, mid, R);
}

public static void merge(int[] arr, int L, int M, int R) {
    int[] res = new int[R - L + 1];
    int i = 0, p1 = L, p2 = M + 1;
    while (p1 <= M && p2 <= R) {
        res[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= M) {
        res[i++] = arr[p1++];
    }
    while (p2 <= R) {
        res[i++] = arr[p2++];
    }
    for (i = 0; i < res.length; i++) {
        arr[L + i] = res[i];
    }
}
```

## 题目

### 小和问题

​	在一个数组中，如果左边的元素**num[i]比右边x个**元素小，那么改元素的小和为**num[i] * x**，请问该数组的小和是多少。

​	比如，在数组[9, 7, 5, 4, 6]中，其中5和4比6小那么小和为**5 * 1 + 4 * 1 = 9**。

#### 问题分析

​	在归并排序的第二步，归集中可以做到**不漏比，不多比，不少比**，且在比较的时候，如果**left[p1] < right[p2]**，**left**和**right**整体就是**有序**的，所有既然**left[p1]<right[p2]**那么left[p1]也**小于**p2之后的数据，所以**left[p1]**的小和为**left[p1] * (R - p2 + 1)**。

#### 代码实现

```java
public static int process(int[] arr, int L, int R) {
    if (L == R) {
        return 0;
    }
    int mid = L + ((R - L) >> 1);
    return process(arr, L, mid) + process(arr, mid + 1, R) + merge(arr, L, mid, R);
}

public static int merge(int[] arr, int L, int M, int R) {
    int[] res = new int[R - L + 1];
    int sum = 0;
    int i = 0, p1 = L, p2 = M + 1;
    while (p1 <= M && p2 <= R) {
        // 小和
        sum += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;
        res[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= M) {
        res[i++] = arr[p1++];
    }
    while (p2 <= R) {
        res[i++] = arr[p2++];
    }
    for (i = 0; i < res.length; i++) {
        arr[L + i] = res[i];
    }
    return sum;
}
```

# 快速排序

> **快速排序（Quick Sort）基本思想**：
>
> 采用经典的分治策略，选择数组中某个元素作为基准数，通过一趟排序将数组分为独立的两个子数组，一个子数组中所有元素值都比基准数小，另一个子数组中所有元素值都比基准数大。然后再按照同样的方式递归的对两个子数组分别进行快速排序，以达到整个数组有序。

## 算法步骤

**1.哨兵划分**

- 随机选择一个数num，将其放到数组最右边，然后定义小于区less为L - 1,大于区为more
- 从第一个数**arr[L]**开始，如果**arr[L] < num**，则将其与小于区的下一个进行交换，同时**less++，L++**
- 如果**arr[L] > num**，则将其与大于区的上一个进行交换，L不变,--more
- 如果**arr[L] == num**，在**L++，其余不变**
- 重复以上步骤，直到**L与more相遇**
- 最后将数组最有变的数据和大于区的第一个元素交换

**2.递归分解**

​	在进行划分之后数据分为小于num的，等于num的，大于num的。然后对小于区和大于区重复哨兵划分和递归分解即可。

## 代码实现

```java
private static void quickSort(int[] arr, int L, int R) {
    if (L < R) {
        AlgUtils.swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
        int[] p = partition(arr, L, R);
        quickSort(arr, L, p[0] - 1);
        quickSort(arr, p[1] + 1, R);
    }

}

private static int[] partition(int[] arr, int L, int R) {
    int less = L - 1;
    int more = R;
    while (L < more) {
        if (arr[L] < arr[R]) {
            AlgUtils.swap(arr, L++, ++less);
        } else if (arr[L] > arr[R]) {
            AlgUtils.swap(arr, L, --more);
        } else {
            L++;
        }

    }
    AlgUtils.swap(arr, more, R);
    return new int[]{less + 1, more};
}
```

# 堆排序

