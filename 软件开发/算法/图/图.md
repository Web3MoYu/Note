# 图

## 1. 图的定义

> **图（Graph）**：由顶点的非空有限集合 $V$ （由 $n > 0$ 个顶点组成）与边的集合 $E$（顶点之间的关系）构成的结构。其形式化定义为 $ G=(V,E) $。

- **顶点（Vertex）**：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。

- **边（Edge）**：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：$ e = <u,v> $，表示从 $u$ 到 $v$ 的一条边，其中  $u$ 称为起始点，$v$ 称为终止点。

  ![img](https://qcdn.itcharge.cn/images/20220307145142.png)

- **子图（Sub Graph）**：对于图$ G=(V,E)$ 与 $ G'=(V',E') $，如果存在 $ V' \subseteq V$，$E' \subseteq E$则称图 $G'$ 是图$G$ 的一个子图。在下面的示意图中我们给出了一个图图$G$ 及其一个子图 $G'$。特别的，根据定义，G*G* 也是其自身的子图。

  ![img](https://qcdn.itcharge.cn/images/20220317163120.png)

## 2. 图的分类

### 2.1 无向图和有向图

  按照边是否有方向，我们可以将图分为两种类型：「无向图」和「有向图」。

- **无向图（Undirected Graph）**：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。
- **有向图（Directed Graph）**：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。

在无向图中，每条边都是由两个顶点组成的无序对。例如下图左侧中的顶点 $v1$ 和顶点 $v2$之间的边记为$(v1,v2)$或 $(v2,v1)$。

在有向图中，有向边也被称为弧，每条弧是由两个顶点组成的有序对，例如下图右侧中从顶点 $v1$到顶点 $v2$ 的弧，记为$<v1,v2>$，$v1$ 被称为弧尾，$v2$ 被称为弧头，如下图所示。

![img](https://qcdn.itcharge.cn/images/20220307160017.png)

如果无向图中有 $n$ 个顶点，则无向图中最多有 $ n\times(n-1)/2$ 条边。而具有 $ n\times(n-1)/2$  条边的无向图称为 **「完全无向图（Completed Undirected Graph）」**。

如果有向图中有 $n$个顶点，则有向图中最多有 $ n\times(n-1)$条弧。而具有 $ n\times(n-1)$ 条弧的有向图称为 **「完全有向图（Completed Directed Graph）」**。

![img](https://qcdn.itcharge.cn/images/20220308151436.png)

下面介绍一下无向图和有向图中一个重要概念 **「顶点的度」**。

- **顶点的度**：与该顶点$v_i$相关联的边的条数，记为 $TD(v_i)$。

例如上图左侧的完全无向图中，顶点 $v_3$ 的度为 $3$。

而对于有向图，我们可以将顶点的度分为 **「顶点的出度」** 和 **「顶点的入度」**。

- **顶点的出度**：以该顶点 $v_i$为出发点的边的条数，记为$OD(v_i)$。
- **顶点的入度**：以该顶点 $v_i$为终止点的边的条数，记为$ID(v_i)$。
- 有向图中某顶点的度 = 该顶点的出度 + 该顶点的入度，即 $TD(v_i)=OD(v_i)+ID(v_i)$

例如上图右侧的完全有向图中，顶点 $v_3$的出度为$3$，入度为$3$，顶点 $v_3$ 的度为 $3+3=6$。

### 2.2 环形图和无环图

**「路径」** 是图中的一个重要概念，对于图 $G=(V,E)$，如果存在顶点序列$v_{i0},v_{i1},v_{i2},\dots,v_{im}$，使得 $(v_{i0},v_{i1}),(v_{i1},v_{i2}),\dots,(v_{im-1},v_{im}) \in E$（即他们都是图 G 的边，对于有向图则是  $<v_{i0},v_{i1}>,<v_{i1},v_{i2}>,\dots,<v_{im-1},v_{im}> \in E$，则称该顶点序列为顶点 $v_{i0}$和顶点$v_{im}$之间的一条路径，其中$v_{i0}$是这条路径的起始点，$v_{im}$是这条路径的终止点。

简单来说，如果顶点 $v_{i0}$可以通过一系列的顶点和边，到达顶点$v_{im}$，则称顶点 $v_{i0}$和顶点$v_{im}$ 之间有一条路径，其中经过的顶点序列则称为两个顶点之间的路径。

- **环（Circle）**：如果一条路径的起始点和终止点相同（即 $v_{i0}==v_{im}$ ），则称这条路径为「回路」或者「环」。
- **简单路径**：顶点序列中顶点不重复出现的路径称为「简单路径」。

而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。

- **环形图（Circular Graph）**：如果图中存在至少一条环路，则该图称为「环形图」。
- **无环图（Acyclic Graph）**：如果图中不存在环路，则该图称为「无环图」。

特别的，在有向图中，如果不存在环路，则将该图称为「有向无环图（Directed Acyclic Graph）」，缩写为 DAG。因为有向无环图拥有为独特的拓扑结构，经常被用于处理动态规划、导航中寻求最短路径、数据压缩等多种算法场景。

如下图所示，分别为：无向无环图、无向环形图、有向无环图和有向环形图。其中有向环形图中的顶点 $v_1、v_2、v_3$ 与相连的边构成了一个环。

![环形图和无环图](https://qcdn.itcharge.cn/images/20220317115641.png)

### 2.3 连通图和非连通图

#### 2.3.1 连通无向图和连通分量

在无向图中，如果从顶点$v_i$到顶点$v_j$有路径，则称顶点 $v_i$和$v_j$是连通的。

- **连通无向图**：在无向图中，如果图中任意两个顶点之间都是连通的，则称该图为连通无向图。
- **非连通无向图**：在无向图中，如果图中至少存在一对顶点之间不存在任何路径，则该图称为非连通无向图。

如下图所示，左侧图中$v_1$与 $$ 都是连通的，所以该图为连通无向图。右侧图中 与$v_2、v_3、v_4$都是连通的，但是 $v_1$和 $v_5、v_6$之间不存在任何路径，则该图为非连通无向图。

![img](https://qcdn.itcharge.cn/images/20220317163249.png)

下面介绍一下无向图的「连通分量」概念。有些无向图可能不是连通无向图，但是其子图可能是连通的。这些子图称为原图的连通子图。而无向图的一个极大连通子图（不存在包含它的更大的连通子图）则称为该图的「连通分量」。

- **连通子图**：如果无向图的子图是连通无向图，则该子图称为原图的连通子图。
- **连通分量**：无向图中的一个极大连通子图（不存在包含它的更大的连通子图）称为该图的连通分量。
- **极大连通子图**：无向图中的一个连通子图，并且不存在包含它的更大的连通子图。

例如上图中右侧的非连通无向图，其本身是非连通的。但顶点 $v_1、v_2、v_3、v_4$与其相连的边构成的子图是连通的，并且不存在包含它的更大的连通子图了，所以该子图是原图的一个连通分量。同理，顶点 $v_5、v_6$ 与其相连的边构成的子图也是原图的一个连通分量。



### 2.4 带权图

有时，图不仅需要表示顶点之间是否存在某种关系，还需要表示这一关系的具体细节。这时候我们需要在边上带一些数据信息，这些数据信息被称为 **权**。在具体应用中，权值可以具有某种具体意义，比如权值可以代表距离、时间以及价格等不同属性。

- **带权图**：如果图的每条边都被赋以⼀个权值，这种图称为带权图。
- **网络**：带权的连通⽆向图称为⽹络。

在下面的示意图中，我们给出了一个带权图的例子。

![img](https://qcdn.itcharge.cn/images/20220317135207.png)

### 2.5 稠密图和稀疏图

根据图中边的稀疏程度，我们可以将图分为「稠密图」和「稀疏图」。这是一个模糊的概念，目前为止还没有给出一个量化的定义。

- **稠密图（Dense Graph）**：有很多条边或弧（边的条数 $e$接近于完全图的边数）的图称为稠密图。
- **稀疏图（Sparse Graph）**：有很少条边或弧（边的条数 $e$远小于完全图的边数，如 $e<n\times\log_210$的图称为稀疏图。



# 图的存储结构和问题应用

## 1. 图的存储结构

图的结构比较复杂，我们需要表示顶点和边。一个图可能有任意多个（有限个）顶点，而且任何两个顶点之间都可能存在边。我们在实现图的存储时，重点需要关注边与顶点之间的关联关系，这是图的存储的关键。

图的存储可以通过「顺序存储结构」和「链式存储结构」来实现。其中顺序存储结构包括邻接矩阵和边集数组。链式存储结构包括邻接表、链式前向星、十字链表和邻接多重表。

接下来我们来介绍几个常用的图的存储结构。在下文中，我们约定用 $n$代表顶点数目，$m$代表边数目，$TD(v_i)$表示顶点 $v_i$的度。

### 1.1 邻接矩阵

**邻接矩阵（Adjacency Matrix）**：使用一个二维数组 adj‾matrix*a**d**j**ma**t**r**i**x* 来存储顶点之间的邻接关系。

- 对于无权图来说，如果 $adj\_matrix[i][j]$ 为 $11$，则说明顶点 $v_i$到$v_j$存在边，如果 $adj_matrix[i][j]$为 $0$，则说明顶点 $v_i$到$v_j$之间不存在边。
- 对于带权图来说，如果$adj\_matrix[i][j]$为$w$，并且 $w\neq\infty$（即 `w != float('inf')`），则说明顶点 $v_i$到$v_j$的权值为 $w$。如果$adj\_matrix[i][j]$为$\infty$（即 `float('inf')`），则说明顶点 $v_i$到$v_j$之间不存在边。

![img](https://qcdn.itcharge.cn/images/20220317144826.png)\

邻接矩阵的特点：

- 优点：实现简单，并且可以直接查询顶点 顶点 $v_i$到$v_j$之间是否有边存在，还可以直接查询边的权值。
- 缺点：初始化效率和遍历效率较低，空间开销大，空间利用率低，并且不能存储重复边，也不便于增删节点。如果当顶点数目过大（比如当 $n>10^5$）时，使用邻接矩阵建立一个$n\times n$的二维数组不太现实。

### 1.2 边集数组

#### 1.2.1 边集数组的原理描述

> **边集数组（Edgeset Array）**：使用一个数组来存储存储顶点之间的邻接关系。数组中每个元素都包含一条边的起点$v_i$、终点$v_i$和边的权值 $val$（如果是带权图）。

![img](https://qcdn.itcharge.cn/images/20220317161454.png)

> edges的长度就是边的个数，然后意思就是vi->vj权值是val

### 1.3 邻接表

#### 1.3.1 邻接表的原理描述

> **邻接表（Adjacency List）**：使用顺序存储和链式存储相结合的存储结构来存储图的顶点和边。其数据结构包括两个部分，其中一个部分是数组，主要用来存放顶点的数据信息，另一个部分是链表，用来存放边信息。

在邻接表的存储方法中，对于对图中每个顶点 $v_i$建立一个线性链表，把所有邻接于$v_i$ 的顶点链接到单链表上。这样对于具有 `n` 个顶点的图而言，其邻接表结构由 `n` 个线性链表组成。

然后我们在每个顶点前边设置一个表头节点，称之为「顶点节点」。每个顶点节点由「顶点域」和「指针域」组成。其中顶点域用于存放某个顶点的数据信息，指针域用于指出该顶点第 `1` 条边所对应的链节点。

为了方便随机访问任意顶点的链表，通常我们会使用一组顺序存储结构（数组）存储所有「顶点节点」部分，顺序存储结构（数组）的下标表示该顶点在图中的位置。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的邻接表结构。

![img](https://qcdn.itcharge.cn/images/20220317154531.png)

> 其中vi 1、2、3、4、5都是顶点放在一个数组中，然后数组中的元素是以vi为起始点所连向的顶点

### 1.4 链式前向星

#### 1.4.1 链式前向星的原理描述

> **链式前向星（Linked Forward Star）**：也叫做静态邻接表，实质上就是使用静态链表实现的邻接表。链式前向星将边集数组和邻接表相结合，可以快速访问一个节点所有的邻接点，并且使用很少的额外空间。

链式前向星采用了一种静态链表的存储方式，可以说是目前建图和遍历效率最高的存储方式。

链式前向星由两种数据结构组成：

- **特殊的边集数组**：`edges`，其中 `edges[i]` 表示第 `i` 条边。`edges[i].vj` 表示第 `i` 条边的终止点，`edges[i].val` 表示第 `i` 条边的权值，`edges[i].next` 表示与第 `i` 条边同起始点的下一条边的存储位置。
- **头节点数组**：`head`，其中 `head[i]` 存储以顶点 `i` 为起始点的第 `1` 条边在数组 `edges` 中的下标。

链式前向星其实并没有改变边集数组原来的存储数学，只是利用 `head` 数组构成静态链表，建立了顶点 $v_i$和顶点  $v_i$所连第 `1` 条边的关系。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的链式前向星结构。

如果需要在该图中遍历顶点$v_1$的所有边，则步骤如下：

- 找到以顶点$v_1$为起始点的的 `1` 条边在数组 `edges` 中的下标，即 `index = head[1] = 1 `。则在 `edges` 数组中找到与顶点 $v_1$  相连的第 `1` 条边为 `edges[1]`，即 $⟨v_1,v_5⟩$，权值为 6。
- 查找 `index = self.edges[1].next = 0 `，则在 `edges` 数组中找到与顶点 $v_1$ 相连的第 `2` 条边 `edges[0]`，即  $⟨v_1,v_2⟩$，权值为 5。
- 继续查找 `index = self.edges[0].next = -1`，则不存在其余边，查找结束。

![img](https://qcdn.itcharge.cn/images/20220317161217.png)

> 简单理解就是head[i]表示的是顶点i为起始点的第一条边在数组edges中的下标，也就是说，如果你要找顶点5所在的第一条边就edges[head[5]]。