# 二叉树

## 遍历

```
														  1
													2			3
												4		5	6		7	
```

### 前序遍历

**递归实现**

```java
public static void preOrderRecur(TreeNode root) {
    if (root == null) {
        return;
    }
    System.out.print(root.val + " ");
    preOrderRecur(root.left);
    preOrderRecur(root.right);
}
```

**非递归**

```java
public static void preOrderStack(TreeNode root) {
    // 头左右 -> 每弹出一个，打印该节点，并压入右子树和左子树
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        System.out.print(node.val + " ");
        if (node.right != null) {
            stack.push(node.right);
        }
        if (node.left != null) {
            stack.push(node.left);
        }
    }
}
```



### 中序遍历

> 后继节点：中序遍历的后一个节点
>
> 前继节点：中序遍历的前一个节点

**递归实现**

```java
public static void inOrderRecur(TreeNode root) {
    if (root == null) {
        return;
    }
    inOrderRecur(root.left);
    System.out.print(root.val + " ");
    inOrderRecur(root.right);
}
```

**非递归**

```java
public static void inOrderStack(TreeNode root) {
    // 对于任意一个树，只要有左树，就压入，没有就弹出打印，并跳到右树，相当于 左中(左中(左中..))就没有右树这个概念了。对于任意一颗树，都可以将其分解为左树或者右树
    Stack<TreeNode> stack = new Stack<>();
    while (!stack.isEmpty() || root != null) {
        if (root != null) {
            stack.push(root);
            root = root.left;
        } else {
            root = stack.pop();
            System.out.print(root.val + " ");
            root = root.right;
        }

    }
}
```



### 后序遍历

**递归实现**

```java
public static void posOrderRecur(TreeNode root) {
    if (root == null) {
        return;
    }
    posOrderRecur(root.left);
    posOrderRecur(root.right);
    System.out.print(root.val + " ");
}
```

**非递归**

```java
public static void posOrderStack(TreeNode root) {
    // 左右头 -> 每弹出一个节点，先把该节点压入help，在压入左右节点，最后遍历help
    Stack<TreeNode> stack = new Stack<>();
    Stack<TreeNode> help = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        help.push(node);
        if (node.left != null) {
            stack.push(node.left);
        }
        if (node.right != null) {
            stack.push(node.right);
        }
    }
    while (!help.isEmpty()) {
        System.out.print(help.pop().val + " ");
    }
}
```

### 层次遍历

```java
public static void widthTraversal(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode poll = queue.poll();
        System.out.print(poll.val + " ");
        if (poll.left != null) {
            queue.add(poll.left);
        }
        if (poll.right != null) {
            queue.add(poll.right);
        }
    }
}
```

### 求树的宽度

> 求一个树的宽度，采用层次遍历，遍历每一个节点的时候，使用一个遍历curLevel记录当前在那个层，然后遍历每一个节点的时候如果时当前层的，就通过一个变量自增。通过map记录该节点在那个层数，然后当前层记录完毕后，进行结算保存最大的。在重置当前层数的数量。

**HashMap的解法**

```java
private static int maxWidth(TreeNode root) {
    int max = Integer.MIN_VALUE;
    int curLevels = 1; // 确认当前层数的
    int curNodes = 0;
    HashMap<TreeNode, Integer> map = new HashMap<>();
    map.put(root, 1); // 记录第一层

    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        TreeNode poll = queue.poll();
        Integer cur = map.get(poll);
        if (cur == curLevels) {
            curNodes++;
        } else {
            curLevels++;// 不一样代表当前层级数变了
            max = Math.max(max, curNodes);
            curNodes = 1; // 注意这里，要写成这样，因为和第一层不一样已经时下一层的第一个了
        }
        if (poll.left != null) {
            queue.add(poll.left);
            map.put(poll.left, curLevels + 1); // 下一层的层级数加1
        }

        if (poll.right != null) {
            queue.add(poll.right);
            map.put(poll.right, curLevels + 1);
        }
    }
    // 这里注意和最后一层的节点数比较
    return Math.max(max, curNodes);
}
```

**无HashMap**

```java
private static int maxWidth2(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    TreeNode curEnd = root; // 永远表示当前层最后一个节点
    TreeNode nextEnd = null; // 表示下一层最后一个节点
    int max = Integer.MIN_VALUE;
    int curNodes = 0;
    while (!queue.isEmpty()) {
        TreeNode cur = queue.poll();
        // 每次加入新的元素，都要赋值给nextEnd，保证nextEnd是该层最后一个
        if (cur.left != null) {
            queue.add(cur.left);
            nextEnd = cur.left;
        }
        if (cur.right != null) {
            queue.add(cur.right);
            nextEnd = cur.right;
        }
        if (cur == curEnd) {
            curNodes++;// 进入这里计算该层最后一个
            System.out.println(curNodes);
            max = Math.max(max, curNodes);
            curNodes = 0;
            curEnd = nextEnd; // 将下一层的赋值给当前层，表示进入下一层了
            continue;
        }
        curNodes++;
    }
    return max;
}
```

# 二叉搜索树

> 当一棵树如果，他的左孩子比他小，右孩子比他大，他就是一个二叉搜索树

```
														  8
													3			6
												2		4	5		7	
```

## 判断

**递归**

```java
private static int preValue = Integer.MIN_VALUE;

private static boolean isBst(TreeNode root){
    if (root == null){
        return true;
    }
    boolean isLeftBst = isBst(root.left);
    // 左树不是
    if (!isLeftBst){
        return false;
    }
    if (root.val <= preValue){
        return false;
    }else{
        preValue = root.val;
    }
    // 判断右树，整颗树都是可以划分成左树或者右树的
    return isBst(root.right);
}
```

**非递归**

```java
private static boolean isBst(TreeNode root){
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    
    int preValue = Integer.MIN_VALUE;
    
    while(!stack.isEmpty() || root != null){
        if (root != null){
            stack.push(root.left);
            root = root.left;
        }else{
            TreeNode cur = stack.pop();
            if (preValue <= cur.val){
                return false;
            }else{
                preValue = cur.val;
            }
            root = cur.right;
        }
    }
    return true; 
}
```

# 完全二叉树

> 当一个树，只有最后一层不满，即使最后一层不满，也是从左到右依次变满的。

## 判断

> 使用层次遍历，在遍历的过程中，如果出现以下情况直接返回false
>
> - 1. 任一节点如果有右孩子，没有左孩子
> - 2. 在条件1不违规的情况下，如果遇到了第一个左右孩子不全，后续必须全是叶子节点(没有孩子)

```java
private static boolean isCBT(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);

    // 是否遇到过左右孩子不全的节点
    boolean leaf = false;
    TreeNode left = null;
    TreeNode right = null;
    while (!queue.isEmpty()) {
        TreeNode poll = queue.poll();
        left = poll.left;
        right = poll.right;

        if (
            // 条件2
                (leaf && (left != null || right != null))
                        ||
                        (left == null && right != null) // 条件1
        ) {
            return false;
        }

        if (left != null) {
            queue.add(left);
        }
        if (right != null) {
            queue.add(right);
        }
        if (left == null || right == null) {
            leaf = true;
        }
    }
    return true;
}
```

# 满二叉树

> 满二叉树是，如果当前层有节点，那么该层必须是满的。深度$C$ ,数量$N$，满足条件$N = 2^C - 1$

## 判断

**笨方法**

> 先统计深度$C$ ,在统计数量$N$，满足$N = 2^C - 1$

**树形DP**

> 满足递归套路

```java
private static class Info {
    int height;
    int nodes;

    public Info(int height, int nodes) {
        this.height = height;
        this.nodes = nodes;
    }
}

private static boolean isFBT(TreeNode root) {
    if (root == null) {
        return true;
    }
    Info data = process(root);
    return data.nodes == (1 << data.height) - 1;
}

private static Info process(TreeNode root) {
    if (root == null) {
        return new Info(0, 0);
    }

    Info leftData = process(root.left);
    Info rightData = process(root.right);

    int height = Math.max(leftData.height, rightData.height) + 1;
    int nodes = leftData.nodes + rightData.nodes + 1;

    return new Info(height, nodes);
}
```



# 平衡二叉树

> 对于任意一个子树来说，左右的高度差，不能超过1(< 2 || <= 1)

```java
// 需要的信息
private static class ReturnType {
    boolean isBalanced;
    int height;

    public ReturnType(boolean isBalanced, int height) {
        this.isBalanced = isBalanced;
        this.height = height;
    }
}

public static void main(String[] args) {
    TreeNode root = TreeNode.init();
    System.out.println(process(root).isBalanced);
}

private static ReturnType process(TreeNode root) {
    if (root == null) { // tree is null
        return new ReturnType(true, 0);
    }

    // 返回左右子树的信息
    ReturnType leftData = process(root.left);
    ReturnType rightData = process(root.right);

    int height = Math.max(leftData.height, rightData.height) + 1;
    // 判断是否满足可能性
    boolean isBalanced = leftData.isBalanced && rightData.isBalanced
            && Math.abs(leftData.height - rightData.height) < 2;
    return new ReturnType(isBalanced, height);
}
```



## 判断

# 递归套路(树形DP)

对于二叉树的题目，如果你可以从左右子树上拿信息，然后满足某些条件即可使用。

比如判断平衡二叉树

可能性：

- 左子树要是平衡二叉树
- 右子树要是平衡二叉树
- 左右字数高度差小于1

需要的信息：

- 左子树是否平衡
- 左子树高度
- 右子树是否平衡
- 右子树高度

查看上述代码即可

**判断是否是二叉搜索树**

> 对于每一个子树来说我都需要以下信息，用于判断是否满足二叉搜索树

```java
ReturnData{
    boolean isBST;
    int min;
    int max;
}
```

```java
public static ReturnData process(TreeNode root){
    if (root == null){ // 因为min和max不好复制所以返回null
        return null;
    }
    
    // 拿到左右子树的信息
    ReturnData leftData = process(root.left);
    ReturnData rightData = process(root.right);
    
    // 拿到信息后，需要返回构造递归的闭环
    boolean isBST = true;
    int min = root.value;
    int max = root.value;
    
    // 处理min,max
    if (leftData != null){
        min = Math.min(min, leftData.min);
        max = Math.max(max, leftData.max);
    }
    if (rightData != null){
        min = Math.min(min, rightData.min);
        max = Math.max(max, rightData.max);
    }
    
    // 处理isBST
    if (leftData != null && (!leftData.isBST || leftData.max >= root.val)){
        isBST = false;
    }
    if (RightData != null && (!rightData.isBST || root.val >= rightData.min)){
        isBST = false;
    }
    
    return new ReturnData(isBST, min, max);
}
```

# 题目

**最低公共祖先**

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // 如果子树上没有p或q就肯定会返回null，有的话就返回
    if (root == null || root == p || root == q) {
        return root;
    }

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    // 自己左右孩子都不为空就返回自己
    if (left != null && right != null) {
        return root;
    }
    // 谁为空返回另外一个，遍历另外一个子树
    return left == null ? right : left;
}
```

**得到后继节点**

对于后继节点有以下两种情况

1. 如果该节点有右树，那么后继节点就是右树最左的孩子
2. 如果没有右树，那么后继节点就是一个左孩子的父节点，就是一直往父节点回溯，且某个父节点是左孩子（注意最右的孩子是没有的(root)）

```java
public static TreeNode getSuccessorNode(TreeNode root){
    if (root == null){
        return root;
    }
    if (root.right != null){
        return getLeftMost(root.right);
    }else{
        TreeNode parent = root.parent;
        // 我一直是我父亲的右孩子
        while(parent != null && parent.left != root){
            root = parent;
            parent = root.parent;
        }
        return parent;
    }
}

public static TreeNode getLeftMost(TreeNode root){
    if (root == null){
        return root;
    }
    while(root.left != null){
        root = root.left;
    }
    return root;
}
```

**折叠纸条**

> 将一张纸条对折N次，打印凹凸情况。
>
> 就是一棵树如果对折三次为
>
> ​																凹
>
> ​													凹						凸
>
> ​											凹		 	凸		  凹 				凸
>
> 然后中序遍历就是从上到下的凹凸情况，除了根节点是凹之外，对于每一个左子树的根都是凹，每一个的右子树的根都是凸

```java
// i是节点的层数		N层数		down==true 凹 down == false 凸
solve(int i, int N. boolean down){
    if (i > N){
        return;
    }
    solve(i + 1, N, true);
    print(down ? "凹 " : "凸");
    solve(i + 1, N， false);
}

solve(1,N,true);
```

